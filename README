abdalla.hle192, shhade.meary
326348679, 323089698

=== MAIN REGULAR EXPRESSIONS ===

1. METHOD DECLARATION PATTERN
Pattern: ^\\s*void\\s+([A-Za-z]\\w*)\\s*\\((.*)\\)\\s*\\{\\s*$

Structure breakdown:
- ^\\s* : Matches start of line with optional leading whitespace
- void\\s+ : Matches the literal "void" keyword followed by required whitespace
- ([A-Za-z]\\w*) : CAPTURE GROUP 1 - Method name must start with a letter, followed by any word characters
 (letters, digits, underscores)
- \\s*\\((.*)\\)\\s* : Optional whitespace, opening parenthesis, CAPTURE GROUP 2
(parameter list - any characters), closing parenthesis, optional whitespace
- \\{\\s*$ : Opening brace followed by optional whitespace and end of line

Purpose: Validates method declaration syntax and extracts the method name and parameter list
for further processing. The pattern ensures proper S-Java method structure while capturing
essential components for semantic validation.

2. VARIABLE DECLARATION PATTERN
Pattern: ^\\s*(final\\s+)?(int|double|String|boolean|char)\\s+(.+?)\\s*$

Structure breakdown:
- ^\\s* : Matches start of line with optional leading whitespace
- (final\\s+)? : CAPTURE GROUP 1 - Optional "final" keyword followed by required whitespace
(the ? makes the entire group optional)
- (int|double|String|boolean|char) : CAPTURE GROUP 2 - Alternation (|) matches exactly one of
the five allowed S-Java types
- \\s+ : Required whitespace separator between type and variable names
- (.+?) : CAPTURE GROUP 3 - Non-greedy match of one or more characters (variable name(s)
 and potential initialization expressions)
- \\s*$ : Optional trailing whitespace and end of line

Purpose: Identifies variable declarations while capturing the final modifier status, variable type,
and the remainder of the declaration (which may contain multiple comma-separated variables with
optional initializations).
The non-greedy quantifier ensures we capture only what's needed before the semicolon.


=== DESIGN CHOICES AND CODE ARCHITECTURE ===

TWO-PASS PARSING STRATEGY:
The design implements a two-pass parsing approach to handle forward references in method calls:
- Pass 1:
Collects all method signatures and builds the global variables table without validating method bodies
- Pass 2:
 Validates all method bodies using the complete methods table,
  enabling methods to call other methods declared later in the file

This separation resolves the forward-reference problem while maintaining clear validation boundaries.

SEPARATION OF CONCERNS:
The code follows a modular architecture where each component has a single, well-defined responsibility:

1. LEXICAL LAYER (ex5.parser.Line):
   - Performs pattern matching to classify raw source lines
   - Uses precompiled regex patterns for performance
   - Returns TypeLineOptions enum values
   - Does NOT perform semantic validation
   - Responsibility: "What kind of statement is this?"

2. SYNTAX/SEMANTIC VALIDATION LAYER:
   Each validator class handles one statement type:

   a) VariableLine (ex5.handleVariables):
      - Validates variable declarations and assignments
      - Enforces final semantics (must initialize, cannot reassign)
      - Checks type compatibility using ValidationUtils
      - Handles both global and local scopes
      - Responsibility: "Is this variable statement legal?"

   b) MethodLine (ex5.handleMethods):
      - Parses method signatures (parseSignature for pass 1)
      - Validates parameter lists (no duplicates, valid types)
      - Orchestrates method body validation
      - Manages scope depth tracking for nested blocks
      - Validates method calls (existence, argument count, type compatibility)
      - Responsibility: "Is this method declaration and body legal?"

   c) IfWhileLine (ex5.handleMethods):
      - Validates conditional statement syntax
      - Splits compound conditions on && and ||
      - Validates each condition term (boolean/int/double literals or variables)
      - Ensures referenced variables are declared and initialized
      - Responsibility: "Is this control flow statement legal?"

3. SCOPE MANAGEMENT (ex5.main.Scopes):
   - Maintains a stack-based scope hierarchy (method scope + nested blocks)
   - Implements variable resolution (inner to outer, then global)
   - Provides declareLocal/resolve interface
   - Does NOT perform validation itself
   - Responsibility: "Where is this variable declared?"

4. SEMANTIC MODELS:
   - Variable (ex5.handleVariables): Stores type, initialization status, final modifier
   - Method (ex5.handleMethods): Stores name and parameter list
   - Method.Parameter: Stores type, name, final modifier
   - These are pure data carriers without validation logic

5. VALIDATION UTILITIES (ex5.validator.ValidationUtils):
   - Centralizes literal validation patterns (int, double, boolean, char, String)
   - Provides type compatibility checking (int→double, int/double→boolean)
   - Validates argument-parameter matching
   - Shared by VariableLine, MethodLine, and IfWhileLine
   - Responsibility: "Are these types compatible?"

6. ORCHESTRATION LAYER (ex5.parser.Parser):
   - Reads entire file into memory for two-pass processing
   - Maintains global tables (variables, methods)
   - Delegates to appropriate validators based on Line classification
   - Handles pass 1 (collect signatures) and pass 2 (validate bodies)
   - Tracks global variable initialization state between passes
   - Responsibility: "Coordinate the overall validation process"

7. ENTRY POINT (ex5.main.Sjavac):
   - Validates command-line arguments and file extension
   - Opens BufferedReader
   - Catches exceptions and translates to exit codes (0=success, 1=syntax error, 2=IO error)
   - Responsibility: "Handle program invocation and error reporting"


ERROR HANDLING STRATEGY:
- Each validator throws specific exceptions (VariableException, MethodException)
- Error messages include descriptive prefixes and the problematic token/variable name
- All exceptions propagate to Sjavac, which converts them to exit code 1
- IO errors are caught separately and result in exit code 2

REGEX USAGE PHILOSOPHY:
- Patterns are precompiled as static final fields for performance
- Complex validation is split: regex for syntax structure, Java logic for semantic rules
- Capture groups extract components for further processing
- Named constants for regex pieces improve maintainability (e.g., NAME, TYPE, VALUE)

SCOPE AND VARIABLE TRACKING:
- Global variables persist throughout parsing
- Method-local scopes are created fresh for each method validation
- Global initialization state is saved before method validation and restored after
- This ensures methods don't affect global variable state during validation

TYPE SYSTEM:
- Supports five types: int, double, boolean, char, String
- Type promotion: int→double, int/double→boolean
- Validation centralized in ValidationUtils for consistency
- Literal matching uses specific patterns per type